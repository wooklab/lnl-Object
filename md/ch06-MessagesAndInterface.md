# 06 메시지와 인터페이스

- 객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것
- 클래스는 개발자가 직접 만지고, 고쳐볼 수 있는 실제적이면서도 구체적인 도구
- 하지만 말그대로 도구일 뿐, 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아짐
- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 `객체들이 주고받는 메시지`

> 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하라

### 01 협력과 메시지

#### 클라이언트-서버 모델

- 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작됨
- 메시지를 매개로 하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성
- 클라이언트-서버(Client-Server) 모델
    - 클라이언트: 메시지를 전송하는 객체
    - 서버: 메시지를 수신하는 객체
    - 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
- 대부분의 사람들은 객체가 수신하는 메시지의 집합에만 초점을 맞추지만
- 협력에 적합한 객체를 설계하기 위해서는 위부에 전송하는 메시지의 집합도 함께 고려하자
- 요점
    - 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 `다른 객체와 협력`해야 함
    - 두 객체 사이의 협력을 가능하게 해주는 매개체가 바로 `메시지`

<br/>

#### 메시지와 메시지 전송

- 메시지(message): 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
- 메시지 전송(message sending) 또는 메시지 패싱(message passing): 한 객체가 다른 객체에게 도움을 요청하는 것
- 메시지 전송자(message sender): 메시지를 전송하는 객체
- 메시지 수신자(message receiver): 메시지를 수신하는 객체
- 클라이언트-서버 모데 관점
    - 클라이언트: 메시지 전송자
    - 서버: 메시지 수신자
- 메시지 = 오퍼레이션명(operation name) + 인자(argument)
- 메시지 전송 = 메시지 수신자(message receiver) + 오퍼레이션명(operation name) + 인자(argument)

```java
condition.isSatisfiedBy(screening); // 메시지 전송
// condition        수신자
// isSatisfiedBy    오퍼레이션명
// screening        인자
```

<br/>

#### 메시지와 메서드

- 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 기준
- 실행되는 코드는 인터페이스를 실체화한 클래스의 종류에 따라 다름
- 메서드: 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
    - 함수 또는 프로시저: 코드의 의미가 컴파일 시점과 실행 시점이 동일
    - 메시지와 메서드: 컴파일 시점과 실행 시점의 의미가 달라질 수 있음
- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 함
    - 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지말 알면 됨
    - 메시지 수신자 역시 누가 메시지를 전송하는지 알 필요없음

> 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확자 가능한 코드를 작성할 수 있게 함

<br/>

#### 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스: 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션(operation)
    - 퍼블릭 인터페이스에 포함된 메시지
    - 수행 가능한 어떤 행동에 대한 추상화
    - 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가르키는 경우
    - 인터페이스의 각 요소
    - 구현이 아닌 추상화
- 메서드
    - 메시지를 수신했을 때 실제로 실행되는 코드
    - 오퍼레이션을 구현한 것
- 객체가 다른 객체에게 메시지를 전송 -> `메서드 호출 보다는 오퍼레이션 호출`로 해석

<br/>

#### 시그니처

- 시그니처(signature): 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것
- 메서드: 시그니처 + 구현
- 오퍼레이션 관점에서 다형성이란?
    - 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행 되는 것

> - 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다
> - 퍼블릭 인터페이스가 객체의 품질을 결정
> - 메시지가 객체의 품질 결정


---

### 02 인터페이스와 설계 품질

- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 함
    - 최소한의 인터페이스: 꼭 필요한 오퍼레이션만 포함
    - 추상적인 인터페이스: 어떻게 수행하는지가 아닌 `무엇을 하는지 표현`
- 좋은 인터페이스를 설계하는 방법
    - 책임 주도 설계 방법을 따르는 것
    - 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지
    - 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현

> **퍼블릭 인터페이스의 품질에 영향을 미치는 원칙**
>  - 디미터 법칙
>  - 묻지 말고 시켜라
>  - 의도를 드러내는 인터페이스
>  - 명령-쿼리

<br/>

#### 디미터 법칙(Law of Demeter)

- 객체의 내부 구조에 강하게 결합되지 않도록 `협력 경로를 제한`
- 낯선 자에게 말하지 말라(don't talk to strangers)
- 오직 인접한 이웃하고만 말하라(only talk to your immediate neihbors)
- 오직 하나의 도트만 사용하라(use only one dot)
- 클래스가 `특정한 조건을 만족하는 대상에게만 메시지를 전송`하도록 프로그래밍해야 함
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체

**기차 충돌(train wreck)**
- 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태
- 메시지 수신자의 `캡슐화는 무너지고`
- 메시지 전송자가 메시지 수신자의 `내부 구현에 강하게 결합`

*단, 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다

<br/>

#### 묻지 말고 시켜라(Tell, Don't Ask)

- 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조
- 메시지 전송자는 메시지 수신자의 상태를 바꿔서는 안됨
- 객체의 정보를 이용하는 행동을 객체 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 됨
- 훌륭한 인터페이스를 수확하기 위해서
    - 객체가 어떻게 작업을 수행하는지 노출해서는 안됨
    - 인터페이스는 객체가 어떻게 하는지가 아닌 `무엇을 하는지를 서술`해야 함

<br/>

#### 의도를 드러내는 인터페이스

- 메서드의 이름을 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 경우
    - 내부의 구현 방법이 드러남
    - 메서드에 대해 제대로 커뮤니케이션하지 못함
    - 더 큰 문제는 메서드 수준에서 캡슐화를 위반한다는 것
- 메서드의 이름을 '어떻게'가 아니라 '무엇'을 하는지 드러내도록 이름 짓는 경우
    - 객체가 협력 안에서 수행해야 하는 책임에 관해 고민하게 됨
    - 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만듬
    - 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 됨

<br/>

- 의도를 드러내는 선택자(Intention Revealing Selector)
    - 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴
- 의도를 드러내는 인터페이스(Intention Revealing Interface)
    - 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에 협력과 관련된 의도만 표현

<br/>

#### 함께 모으기

디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스를 이해할 수 있는 좋은 방법 중 하나는 이런 원칙을 위반하는 코드의 모습을 살펴 보는 것

(코드는 책 또는 Object 공식 github 참조)

- 디미터 법칙과 묻지 말고 시켜라 스타일을 따르면
    - 자율적인 객체로 구성된 유연한 협력을 얻게 됨
    - 구현이 객체의 퍼블릭 인터페이스에 노출되지 않아 결합도가 낮아짐
    - 책임이 잘못된 곳에 할당될 가능성이 낮아지기 때문에 응집도가 높아짐
- 따라서 클라리언트의 의도가 분명하게 드러나도록 객체의 퍼블릭 인터페이스를 개선하자


---

### 03 원칙의 함정

- 디미터 법칙과 묻지 말고 시켜라 스타일은 절대적인 법칙은 아니다.
- 법칙에는 예외가 없지만 원칙에는 예외가 넘쳐난다.
- 설계는 트레이드오프의 산물
- 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라

<br/>

#### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

- 모두 동일한 클래스의 인스턴스를 반환하는 경우는 디미터 법칙을 위반하는 것이 아님 (
- e.g.
  ```java
  IntStream.of(1,15,20,3,9).filter(x -> x > 10).distinct().count();
  ```
- 디미터 법칙은 결합도와 관련된 것이며 객체의 내부 구조가 외부로 노출되는 경우에 문제가 됨.


#### 결합도와 응집도의 충돌

> 어떤 객체의 `상태`를 물어본 후 반환된 상태를 기반으로 `결정`을 내리고 그 결정에 따라 객체의 `상태를 변경`하는 코드는 묻지 말고 시켜라 스타일로 변경해야 한다.

- 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 
    - 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법
- 묻지 말고 시켜라와 디미터 법칙을 준수하는 것이 항상 긍정적인 결과로만 귀결되는 것은 아님
    - `맹목적인 위임 메서드 추가`는 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존
    - 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 `응집도가 낮아짐`
- 디미터 법칙의 위반 여부는 묻는 대상이 객체인지, 자료 구조인지에 달려있음
    - 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따름
    - 자료구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요 없음


---

### 04 명령-쿼리 분리 원칙

> <명령-쿼리 분리 원칙><br/>
> 퍼블릭 인터페이스의 오퍼레이션을 정의할 때 참고할 수 있는 지침 제공

- 루틴(routine)
    - 어떤 절차를 묶어 호출 가능하도록 이름을 부여안 기능 모듈
    - 루틴은 프로시저(procedure)와 함수(function)으로 구분
- 프로시저
    - 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    - 부수효과를 발생, 값을 반환하진 않음
    - 객체의 상태를 수정하는 오퍼레이션 = 명령
- 함수
    - 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    - 부수효과 없음, 값 반환
    - 객체와 관련된 정보를 반환하는 오퍼레이션 = 쿼리

명령-쿼리 분리 원칙
- 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다
- 질문이 답변을 수정해서는 안 된다
- 명령은 상태를 변경할 수 있지만 상태를 반환해선 안된다
- 쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안된다

<br/>

#### 반복 일정의 명령과 쿼리 분리하기

- 명령과 쿼리를 뒤섞으면
    - 겉으로 보기에는 쿼리처럼 보이지만 내부적으로는 부수효과를 가지는 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양상하는 경향이 있다.
    - 해결책은 명령과 쿼리를 명확하게 분리
- 퍼블릭 인터페이스를 설계할 때
    - 명령과 쿼리를 분리하자

<br/>

#### 명령-쿼리 분리와 참조 투명성
- 명령-쿼리 분리의 장점
    - 쿼리는 객체의 상태를 변경하지 않음
    - 쿼리는 반복적을 호출하더라도 상관 없음
    - 쿼리의 결과를 예측하기 쉬움
    - 쿼리들의 순서를 자유롭게 변경 가능
- 부수효과(side effect)
    - 컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징은 의 존재 유무
- 참조 투명성
    - 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
    ```
    f(1) = 3 이면
    f(1) + f(1) = 6
    f(1) * 2    = 6
    f(1) - 1    = 2
    => f(1)을 3이라는 값으로 바꾸더라도 수식의 결과는 달라지지 않음
    ```
- 불변성(immutability)
    - 어떤 값이 변하지 않는 성질
    - 부수효과를 방지하고 참조 투명성을 만족시킴

> 객체지향 패러다임이 객체의 상태 변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에 가깝다. 하지만 명령-쿼리 분리 원칙을 사용하면 이 균열을 조금이나마 줄일 수 있다.

<br/>

#### 책임에 초점을 맞춰라

- 인터페이스 설계하는 쉬운 방법
    - 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택
- 객체의 협력 방식을 명시적으로 드러내는 방법
    - 객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것
- 중요한 것은 협력에 적합한 객체가 아니라 협력에 적합한 메시지